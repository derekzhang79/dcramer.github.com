<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ci | David Cramer's Blog]]></title>
  <link href="http://justcramer.com/categories/ci/atom.xml" rel="self"/>
  <link href="http://justcramer.com/"/>
  <updated>2012-05-03T11:25:42-07:00</updated>
  <id>http://justcramer.com/</id>
  <author>
    <name><![CDATA[David Cramer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Travis-CI with Python and Django]]></title>
    <link href="http://justcramer.com/2012/05/03/using-travis-ci"/>
    <updated>2012-05-03T11:13:00-07:00</updated>
    <id>http://justcramer.com/2012/05/03/using-travis-ci</id>
    <content type="html"><![CDATA[<p>I've been using <a href="http://travis-ci.org">Travis-CI</a> for a few weeks now. Both my personal projects,
and even several of the libraries we maintain at DISQUS rely on it for Continuous Integration. I figured it was about time to confess
my undenying love for Travis, and throw up some notes about the defaults we use in our projects.</p>




<p>Getting started with Travis-CI is pretty easy. It involves putting a <code>.travis.yml</code> file in the root of
your project, and configuring the hooks between GitHub and Travis. While it's not always easy to get the hooks configured
when you're using organizations, I'm not going to talk much about that. What I do want to share is how we've structured
our configuration files for our Django and Python projects.</p>




<p>A basic <code>.travis.yml</code> might look something like this:</p>


<p>{% codeblock lang:yaml %}
language: python
python:
  - "2.6"
  - "2.7"
install:
  - pip install -q -e . --use-mirrors
script:
  - python setup.py test
{% endcodeblock %}</p>

<p>Most of the projects themselves use Django, which also means they need to test several Django versions. Travis makes
this very simple with its matrix builds. In our case, we need to setup a DJANGO matrix, and ensure it gets installed:</p>


<p>{% codeblock lang:yaml %}
env:
  - DJANGO=1.2.7
  - DJANGO=1.3.1
  - DJANGO=1.4
install:
  - pip install -q Django==$DJANGO --use-mirrors
  - pip install -q -e . --use-mirrors
{% endcodeblock %}</p>

<p>Additionally we generally conform to pep8, and we always want to run pyflakes against our build. We use a custom
version of pyflakes which allows us to filter out warnings, as those are never critical errors:</p>


<p>{% codeblock lang:yaml %}
install:
  - pip install -q Django==$DJANGO --use-mirrors
  - pip install pep8 --use-mirrors
  - pip install https://github.com/dcramer/pyflakes/tarball/master
  - pip install -q -e . --use-mirrors
script:
  - "pep8 --exclude=migrations --ignore=E501,E225 src"
  - pyflakes -x W src
  - python setup.py test
{% endcodeblock %}</p>

<p>When all is said and done, we end up with something like this:</p>


<p>{% codeblock lang:yaml %}
language: python
python:
  - "2.6"
  - "2.7"
env:
  - DJANGO=1.2.7
  - DJANGO=1.3.1
  - DJANGO=1.4
install:
  - pip install -q Django==$DJANGO --use-mirrors
  - pip install pep8 --use-mirrors
  - pip install https://github.com/dcramer/pyflakes/tarball/master
  - pip install -q -e . --use-mirrors
script:
  - "pep8 --exclude=migrations --ignore=E501,E225 src"
  - pyflakes -x W src
  - python setup.py test
{% endcodeblock %}</p>

<p>Travis will automatically matrix each environment variable with each Python version, so you'll get
a test run for every combination of the two. Pretty easy, right?</p>

]]></content>
  </entry>
  
</feed>
